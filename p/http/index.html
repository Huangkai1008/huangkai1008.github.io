<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HTTP 一、概述 超文本传输协议（HyperText Transfer Protocol, HTTP） 是 Web 的核心，HTTP 由客户端程序和服务器程序实现 HTTP 使用 TCP 作为它的支撑运输协议，因为"><title>HTTP</title>
<link rel=canonical href=https://huangkai1008.github.io/p/http/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="HTTP">
<meta property="og:description" content="HTTP 一、概述 超文本传输协议（HyperText Transfer Protocol, HTTP） 是 Web 的核心，HTTP 由客户端程序和服务器程序实现 HTTP 使用 TCP 作为它的支撑运输协议，因为">
<meta property="og:url" content="https://huangkai1008.github.io/p/http/">
<meta property="og:site_name" content="Huanghuang's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="计算机网络"><meta property="article:tag" content="HTTP"><meta property="article:published_time" content="2020-06-12T12:22:57+08:00"><meta property="article:modified_time" content="2020-07-16T21:24:19+08:00">
<meta name=twitter:title content="HTTP">
<meta name=twitter:description content="HTTP 一、概述 超文本传输协议（HyperText Transfer Protocol, HTTP） 是 Web 的核心，HTTP 由客户端程序和服务器程序实现 HTTP 使用 TCP 作为它的支撑运输协议，因为">
<link rel="shortcut icon" href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211018164707.jpg>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-149768628-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ style=background-color:#2a9d8f;color:#fff>
计算机网络
</a>
</header>
<h2 class=article-title>
<a href=/p/http/>HTTP</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 12, 2020</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
14 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h1 id=http>HTTP</h1>
<h2 id=一概述>一、概述</h2>
<blockquote>
<p><strong>超文本传输协议（<code>HyperText Transfer Protocol, HTTP</code>）</strong> 是 Web 的核心，HTTP 由客户端程序和服务器程序实现</p>
</blockquote>
<p><strong>HTTP 使用 TCP 作为它的支撑运输协议</strong>，因为 HTTP 服务器并不保存关于客户的任何信息，所以 HTTP 是一个<strong>无状态协议（<code>stateless protocol</code>）</strong>。</p>
<h3 id=请求和响应报文>请求和响应报文</h3>
<p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>
<h4 id=请求消息requests><strong>请求消息（<code>requests</code>）</strong></h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>developer.mozilla.org</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>fr</span>
</code></pre></div><ul>
<li>
<p><strong>起始行（<code>start line</code>）</strong>：包含一个<a class=link href=#%e4%ba%8c%e3%80%81HTTP%e6%96%b9%e6%b3%95>HTTP方法（<code>method</code>）</a>、<strong>请求目标（<code>request target</code>）</strong> 和 <strong>HTTP 版本 （<code>HTTP version</code>）</strong></p>
</li>
<li>
<p><strong>消息头（<code>headers</code>）</strong>： 整个 header（包括其值）表现为单行形式</p>
</li>
<li>
<p>一个空行用来分隔首部和内容主体 Body</p>
</li>
<li>
<p><strong>消息主体（<code>body</code>）</strong></p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20210906175921.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20210906175921.png loading=lazy alt="HTTP Requests Example">
</a>
<figcaption>HTTP Requests Example</figcaption>
</figure></p>
<hr>
</li>
</ul>
<h4 id=响应消息responses><strong>响应消息(<code>responses</code>)</strong></h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>200</span> <span class=ne>OK</span>
<span class=n>Date</span><span class=o>:</span> <span class=l>Sat, 09 Oct 2010 14:28:02 GMT</span>
<span class=n>Server</span><span class=o>:</span> <span class=l>Apache</span>
<span class=n>Last-Modified</span><span class=o>:</span> <span class=l>Tue, 01 Dec 2009 20:18:22 GMT</span>
<span class=n>ETag</span><span class=o>:</span> <span class=l>&#34;51142bc1-7449-479b075b2891b&#34;</span>
<span class=n>Accept-Ranges</span><span class=o>:</span> <span class=l>bytes</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>29769</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html</span>

<span class=err>&lt;</span>!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
</code></pre></div><ul>
<li><strong>状态行（<code>status line</code>)</strong>：
<ul>
<li><strong>协议版本</strong>，通常为 <code>HTTP/1.1</code>.</li>
<li><strong>状态码 (<code>status code</code>)</strong>，表明请求是成功或失败。常见的状态码是 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200 target=_blank rel=noopener><code>200</code></a>，<a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404 target=_blank rel=noopener><code>404</code></a>，或 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302 target=_blank rel=noopener><code>302</code></a></li>
<li><strong>状态文本 (<code>status text</code>)</strong>：一个简短的，纯粹的信息，通过状态码的文本描述，帮助理解该 HTTP 消息</li>
</ul>
</li>
<li><strong>消息头（<code>Headers</code>）</strong>： 整个 header（包括其值）表现为单行形式</li>
<li><strong>一个空行</strong>用来分隔首部和内容主体 Body</li>
<li><strong>消息主体（<code>body</code>）</strong></li>
</ul>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20210906205815.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20210906205815.png loading=lazy alt="HTTP Responses Example">
</a>
<figcaption>HTTP Responses Example</figcaption>
</figure></p>
<hr>
<h2 id=二http-方法>二、HTTP 方法</h2>
<table>
<thead>
<tr>
<th style=text-align:center>请求方法</th>
<th style=text-align:center>描述</th>
<th style=text-align:center>RFC</th>
<th style=text-align:center>请求具有请求实体</th>
<th style=text-align:center>响应具有响应实体</th>
<th style=text-align:center>安全方法</th>
<th style=text-align:center>是否幂等</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center><strong>GET</strong></td>
<td style=text-align:center>请求一个指定的资源</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>可选</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
</tr>
<tr>
<td style=text-align:center><strong>HEAD</strong></td>
<td style=text-align:center>获取报文首部，不返回报文实体主体，主要用于确认 URL 的有效性以及资源更新的日期时间等</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>可选</td>
<td style=text-align:center>否</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
</tr>
<tr>
<td style=text-align:center><strong>POST</strong></td>
<td style=text-align:center>用于将实体提交到指定的资源</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>否</td>
<td style=text-align:center>否</td>
</tr>
<tr>
<td style=text-align:center><strong>PUT</strong></td>
<td style=text-align:center>向指定资源位置上传其最新内容</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>否</td>
<td style=text-align:center>是</td>
</tr>
<tr>
<td style=text-align:center><strong>PATCH</strong></td>
<td style=text-align:center>对资源进行部分修改</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc5789 target=_blank rel=noopener>5789</a></td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>否</td>
<td style=text-align:center>否</td>
</tr>
<tr>
<td style=text-align:center><strong>DELETE</strong></td>
<td style=text-align:center>删除指定的资源</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>可选</td>
<td style=text-align:center>是</td>
<td style=text-align:center>否</td>
<td style=text-align:center>是</td>
</tr>
<tr>
<td style=text-align:center><strong>CONNECT</strong></td>
<td style=text-align:center>要求在与代理服务器通信时建立隧道</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>可选</td>
<td style=text-align:center>是</td>
<td style=text-align:center>否</td>
<td style=text-align:center>否</td>
</tr>
<tr>
<td style=text-align:center><strong>OPTIONS</strong></td>
<td style=text-align:center>查询指定的 URL 能够支持的方法</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>可选</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
</tr>
<tr>
<td style=text-align:center><strong>TRACE</strong></td>
<td style=text-align:center>服务器会将通信路径返回给客户端</td>
<td style=text-align:center><a class=link href=https://en.wikipedia.org/wiki/RFC_%28identifier%29 target=_blank rel=noopener>RFC</a> <a class=link href=https://datatracker.ietf.org/doc/html/rfc7231 target=_blank rel=noopener>7231</a></td>
<td style=text-align:center>否</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
<td style=text-align:center>是</td>
</tr>
</tbody>
</table>
<h3 id=http方法的安全性>HTTP方法的安全性</h3>
<p>如果说一个 HTTP 方法是<strong>安全（<code>safe</code>）</strong> 的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：<code>GET</code>，<code>HEAD</code> 和 <code>OPTIONS</code>。所有安全的方法都是幂等的，但并非所有幂等方法都是安全的，例如，<code>PUT</code> 和 <code>DELETE</code>都是幂等的，但不是安全的。</p>
<h3 id=http方法的幂等性>HTTP方法的幂等性</h3>
<p>一个HTTP方法是<strong>幂等（<code>idempotent</code>）</strong> 的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下， <code>GET</code>， <code>HEAD</code>， <code>PUT</code> 和 <code>DELETE</code>等方法都是<strong>幂等</strong>的，而 <code>POST</code>方法不是。所有的 <strong>安全</strong>方法也都是幂等的。</p>
<p>幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。例如，第一次调用 <code>DELETE</code>方法有可能返回<strong>200</strong>，但是后续的请求可能会返回 <strong>404</strong> 。 <code>DELETE</code> 的言外之意是，开发者不应该使用 <code>DELETE</code> 法实现具有删除最后条目功能的 RESTful API。</p>
<p>需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。</p>
<hr>
<h2 id=三http-首部header>三、HTTP 首部（<code>header</code>)</h2>
<table>
<thead>
<tr>
<th style=text-align:center>类型</th>
<th style=text-align:center>描述</th>
<th style=text-align:center>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center><strong>通用头（<code>General headers</code>）</strong></td>
<td style=text-align:center>适用于请求和响应信息的头字段</td>
<td style=text-align:center><code>Date</code>,<code>Cache-Control</code></td>
</tr>
<tr>
<td style=text-align:center><strong>请求头（<code>Request headers</code>）</strong></td>
<td style=text-align:center>用于表示请求信息的附加信息的头字段</td>
<td style=text-align:center><code>Authorization</code>,<code>User-Agent</code>,<code>Accept-Encoding</code></td>
</tr>
<tr>
<td style=text-align:center><strong>响应头（<code>Response headers</code>）</strong></td>
<td style=text-align:center>用于表示响应信息的附加信息的头字段</td>
<td style=text-align:center><code>Location</code>,<code>Server</code></td>
</tr>
<tr>
<td style=text-align:center><strong>实体头（<code>Entity headers</code>）</strong></td>
<td style=text-align:center>用于表示实体（消息体）的附加信息的头字段</td>
<td style=text-align:center><code>Allow</code>,<code>Content-Encoding</code>,<code>Expires</code>, <code>Etag</code></td>
</tr>
</tbody>
</table>
<h2 id=四http-状态码status-code>四、HTTP 状态码（<code>status code</code>）</h2>
<table>
<thead>
<tr>
<th style=text-align:center>状态码</th>
<th style=text-align:center>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>1xx(<em>informational response</em>)</td>
<td style=text-align:center>告知请求的处理进度和情况</td>
</tr>
<tr>
<td style=text-align:center>2xx(<em>successful</em>)</td>
<td style=text-align:center>成功</td>
</tr>
<tr>
<td style=text-align:center>3xx(<em>redirection</em>)</td>
<td style=text-align:center>需要进一步处理</td>
</tr>
<tr>
<td style=text-align:center>4xx(<em>client error</em>)</td>
<td style=text-align:center>客户端错误</td>
</tr>
<tr>
<td style=text-align:center>5xx(<em>server error</em>)</td>
<td style=text-align:center>服务器错误</td>
</tr>
</tbody>
</table>
<h2 id=五连接管理>五、连接管理</h2>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211030124313.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211030124313.png loading=lazy alt="HTTP 1.X 的连接类型">
</a>
<figcaption>HTTP 1.X 的连接类型</figcaption>
</figure></p>
<h3 id=非持续连接和持续连接>非持续连接和持续连接</h3>
<blockquote>
<p>每个请求及其响应对经一个单独的 TCP 连接发送，此种方式称为使用<strong>非持续连接（<code>non-persistent connection</code>）</strong>，也可以称为<strong>短连接</strong>；</p>
<p>多个请求及其响应经过相同的TCP连接发送，此种方式称为使用<strong>持续连接（<code>persistent connection</code>）</strong>，也可以称为<strong>长连接</strong>、<strong>连接保活（<code>keep alive</code>）</strong>、<strong>连接复用（<code>connection reuse</code>）</strong>；</p>
</blockquote>
<p><strong>这里的持续连接（长连接）和非持续连接（短连接）指的都是TCP连接</strong>。</p>
<p>从 <strong>HTTP/1.1</strong> 开始默认使用持续连接，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</p>
<p>在 <strong>HTTP/1.1</strong> 之前默认使用非持续连接的，如果需要使用持续连接，则使用 <code>Connection : Keep-Alive</code>。</p>
<h4 id=非持续连接的问题>非持续连接的问题</h4>
<ul>
<li>必须为每一个请求的对象建立和维护一个全新的连接，<strong>会产生大量的开销</strong>，给 web 服务器带来严重负担</li>
<li>每一个对象经受两倍 RTT（<code>Round-Trip Time, RTT, 即往返时延</code>）的交付时延（一个 RTT 创建 TCP，一个RTT请求和接受一个对象），效率较低</li>
</ul>
<h4 id=持续连接的问题>持续连接的问题</h4>
<p>持续连接在空闲状态也消耗服务器资源，而且在重负载时，还有可能遭受 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Glossary/DOS_attack target=_blank rel=noopener>DoS</a> 攻击，对于这种情况一般采取的策略是：</p>
<ol>
<li>
<p>关闭一些长时间没有发生请求的连接</p>
</li>
<li>
<p>限制每个客户端的最大连接数，避免恶意的客户端影响服务端</p>
</li>
</ol>
<p>以<code>Nginx</code>为例 ：</p>
<ol>
<li>可以通过 <code>keepalive_timeout</code> 参数设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源</li>
<li>可以通过 <code>keepalive_requests</code> 参数设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接</li>
</ol>
<h2 id=六cookie-和-session>六、Cookie 和 Session</h2>
<h3 id=http-cookies>HTTP Cookies</h3>
<blockquote>
<p><strong>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）</strong> 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie 使基于<a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless target=_blank rel=noopener>无状态</a>的 HTTP 协议记录稳定的状态信息成为了可能</strong></p>
</blockquote>
<p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API target=_blank rel=noopener>Web storage API</a> （本地存储和会话存储）或 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API target=_blank rel=noopener>IndexedDB</a> 。</p>
<h4 id=用途>用途</h4>
<ul>
<li>
<p><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</p>
</li>
<li>
<p><strong>个性化设置</strong>（如用户自定义设置、主题等）</p>
</li>
<li>
<p><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</p>
</li>
</ul>
<h4 id=创建过程>创建过程</h4>
<p>当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<h5 id=set-cookie响应头部和cookie请求头部><strong>Set-Cookie响应头部和Cookie请求头部</strong></h5>
<p>服务器使用 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie target=_blank rel=noopener><code>Set-Cookie</code></a> 响应头部向用户代理（一般是浏览器）发送 Cookie信息。一个简单的 Cookie 可能像这样：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Set-Cookie: <span class=p>&lt;</span><span class=nt>cookie名</span><span class=p>&gt;</span>=<span class=p>&lt;</span><span class=nt>cookie值</span><span class=p>&gt;</span>
</code></pre></div><p>服务器通过该头部告知客户端保存 Cookie 信息，客户端得到响应报文后把 Cookie 内容保存到浏览器中：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.0</span> <span class=m>200</span> <span class=ne>OK</span>
<span class=n>Content-type</span><span class=o>:</span> <span class=l>text/html</span>
<span class=n>Set-Cookie</span><span class=o>:</span> <span class=l>yummy_cookie=choco</span>
<span class=n>Set-Cookie</span><span class=o>:</span> <span class=l>tasty_cookie=strawberry</span>

[page content]
</code></pre></div><p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求首部字段再发送给服务器：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/sample_page.html</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>www.example.org</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>yummy_cookie=choco; tasty_cookie=strawberry</span>
</code></pre></div><h4 id=生命周期>生命周期</h4>
<ul>
<li><strong>会话期 Cookie</strong>：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效</li>
<li><strong>持久性 Cookie</strong>：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre></div><h4 id=作用域>作用域</h4>
<h5 id=domain-标识><strong>Domain 标识</strong></h5>
<p><code>Domain</code>标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<h5 id=path-标识><strong>Path 标识</strong></h5>
<p><code>Path</code> 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h4 id=限制访问>限制访问</h4>
<h5 id=secure-属性><strong>Secure 属性</strong></h5>
<p>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防<strong>中间人</strong>的攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p>
<h5 id=httponly-属性><strong>HttpOnly 属性</strong></h5>
<p>标记为 <code>HttpOnly</code> 的 Cookie 不能被 JavaScript 脚本调用。<strong>跨站脚本攻击 (XSS)</strong> 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<p>示例：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre></div><p>以下为一个Golang实现的简单的使用 Cookie 的代码示例：</p>
<script type=application/javascript src=https://gist.github.com/Huangkai1008/84e3f3dd5f399412e7bdae4a348551fe.js></script>
<h3 id=session>Session</h3>
<blockquote>
<p><code>Session</code> 代表着服务器和客户端一次会话的过程。<code>Session</code> 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束</p>
</blockquote>
<h3 id=cookie-和-session-的不同>Cookie 和 Session 的不同</h3>
<ul>
<li><strong>作用范围不同</strong>，<code>Cookie</code> 保存在客户端，<code>Session</code> 保存在服务端</li>
<li><strong>存取方式的不同</strong>，<code>Cookie</code> <strong>只能保存 ASCII</strong>，<code>Session</code> 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息</li>
<li><strong>有效期不同</strong>，<code>Cookie</code> 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效</li>
<li><strong>隐私策略不同</strong>，<code>Cookie</code> 存储在客户端，比较容易遭到不法获取；<code>Session</code> 存储在服务端，安全性相对要好一些</li>
<li><strong>存储大小不同</strong>， <strong>单个 <code>Cookie</code> 保存的数据不能超过 4KB</strong>，<code>Session</code> 可存储上限远高于 <code>Cookie</code></li>
</ul>
<h2 id=七web-缓存>七、Web 缓存</h2>
<blockquote>
<p><strong>Web缓存（<code>Web cache</code>）</strong>（或 <strong>HTTP 缓存（<code>HTTP cache</code>）</strong>）是用于临时存储（缓存）Web文档（如HTML页面和图像），以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。 Web缓存系统既可以指设备，也可以指计算机程序</p>
</blockquote>
<h3 id=缓存的种类>缓存的种类</h3>
<p>缓存的种类有很多,其大致可归为两类：<strong>私有</strong>与<strong>共享缓存</strong>。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211113114522.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211113114522.png loading=lazy alt=缓存的种类>
</a>
<figcaption>缓存的种类</figcaption>
</figure></p>
<h4 id=私有浏览器缓存><strong>（私有）浏览器缓存</strong></h4>
<p><strong>私有缓存（<code>local cache</code>/<code>private cache</code>）</strong> 只能用于单独用户。浏览器缓存拥有用户通过 HTTP 下载的所有文件，可以避免再次向服务器发起多余的请求，也可以提供缓存内容的离线浏览。</p>
<h4 id=共享代理缓存><strong>（共享）代理缓存</strong></h4>
<p><strong>共享缓存（<code>shared cache</code>/<code>proxy cache</code>）</strong> 可以被多个用户使用。例如，ISP 或者公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户，这样热门的资源就会被重复使用，减少网络拥堵与延迟。</p>
<h3 id=缓存控制>缓存控制</h3>
<h4 id=cache-control>Cache-Control</h4>
<p><strong>HTTP/1.1</strong>定义的 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control target=_blank rel=noopener><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<h5 id=禁止进行缓存><strong>禁止进行缓存</strong></h5>
<p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: no-store
</code></pre></div><h5 id=强制确认缓存><strong>强制确认缓存</strong></h5>
<p>缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: no-cache
</code></pre></div><h5 id=私有缓存和公共缓存><strong>私有缓存和公共缓存</strong></h5>
<p><strong><code>private</code></strong> 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: private
</code></pre></div><p><strong><code>public</code></strong> 指令规定了将资源作为公共缓存，可以被任何中间人（比如中间代理、CDN等）缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: public
</code></pre></div><h5 id=过期><strong>过期</strong></h5>
<p><strong><code>max-age</code></strong> 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存，</p>
<p><strong><code>max-age</code></strong> 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: max-age=31536000
</code></pre></div><p><strong><code>Expires</code></strong> 首部字段也可以用于告知缓存服务器该资源什么时候会过期：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Expires: Wed, 04 Jul 2012 08:26:05 GMT
</code></pre></div><p>在<strong>HTTP/1.1</strong>中，会优先处理 <strong><code>max-age</code></strong> 指令，在<strong>HTTP/1.0</strong>中，会忽略掉 <strong><code>max-age</code></strong> 指令。</p>
<h5 id=验证方式><strong>验证方式</strong></h5>
<p>当使用了 <strong><code>must-revalidate</code></strong> 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Cache-Control: must-revalidate
</code></pre></div><h4 id=新鲜度freshness>新鲜度(<code>freshness</code>)</h4>
<blockquote>
<p>服务端和客户端为资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，<strong>一个陈旧的资源（缓存副本）是不会直接被清除或忽略的</strong></p>
</blockquote>
<p>对于含有特定头信息的请求，会去计算缓存寿命。比如<code>Cache-control: max-age=N</code>的头，相应的缓存的寿命就是<code>N</code>。</p>
<p>缓存失效时间计算公式如下：
$$
expirationTime = responseTime + freshnessLifetime - currentAge
$$
其中，<code>responseTime</code> 表示浏览器接收到此响应的时间点。</p>
<h4 id=缓存验证validation>缓存验证(<code>validation</code>)</h4>
<h5 id=etag><strong>ETag</strong></h5>
<blockquote>
<p><strong><code>ETag</code></strong> 响应头是 URL 的<code>Entity Tag</code>，作为一个URL资源的标识符，作为缓存的一种<strong>强校验器</strong></p>
</blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>ETag: &#34;82e22293907ce725faf67773957acd12&#34;
</code></pre></div><p>当服务端返回资源时，可以根据返回内容计算一个 hash 值或者就是一个数字版本号作为 ETag 的值放到响应首部中，客户端可以在后续的请求的头中可以将缓存资源的 ETag 值放到 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match target=_blank rel=noopener><code>If-None-Match</code></a> 头首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 <code>304 Not Modified</code>。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>If-None-Match: &#34;82e22293907ce725faf67773957acd12&#34;
</code></pre></div><h5 id=last-modified><strong>Last-Modified</strong></h5>
<p><strong><code>Last-Modified</code></strong> 响应头可以作为缓存验证的一种<strong>弱校验器</strong>，如果响应头里含有这个信息，客户端可以在后续的请求中带上 <a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since target=_blank rel=noopener><code>If-Modified-Since</code></a> 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <code>200 OK</code>。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 <code>304 Not Modified</code> 响应报文。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre></div><h5 id=etag-与-last-modified的对比>Etag 与 Last-Modified的对比</h5>
<p><code>Etag</code> 是强校验器，<code>Last-Modified</code> 是弱校验器，都同时出现时，<strong><code>Etag</code>的优先级更高</strong>。<strong><code>Last-Modified</code>的精度只能到秒</strong>，如果一个资源频繁修改，用<code>Last-Modified</code>并不能区分，而<code>Etag</code> 由于每次资源更新时都会生成新的值，会使缓存验证更加准确，缺点是频繁生成的策略可能会额外消耗服务器资源。</p>
<h3 id=强制缓存与协商缓存>强制缓存与协商缓存</h3>
<blockquote>
<p><strong>强制缓存</strong>：浏览器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回状态码<code>200 OK</code>；</p>
<p><strong>协商缓存</strong>：浏览器向服务器发送请求，服务器会根据这个请求的请求首部来判断是否命中协商缓存，如果命中，则返回<code>304 Not Modified</code>并带上新的响应首部通知浏览器从缓存中读取资源</p>
</blockquote>
<h5 id=强制缓存的首部字段>强制缓存的首部字段</h5>
<ul>
<li><strong><code>Expires</code></strong></li>
<li><strong><code>Cache Control</code></strong></li>
</ul>
<h5 id=协商缓存的首部字段>协商缓存的首部字段</h5>
<ul>
<li>
<p><strong><code>Etag</code></strong> & <strong><code>If-None-Match</code></strong></p>
</li>
<li>
<p><strong><code>Last-Modifed</code></strong> & <strong><code>If-Modified-Since</code></strong></p>
</li>
</ul>
<p><strong>强制缓存</strong>和<strong>协商缓存</strong>都存在的情况下，先判断<strong>强制缓存</strong>是否生效，如果生效，不用发起请求，直接用缓存。如果<strong>强制缓存</strong>不生效再发起请求判断<strong>协商缓存</strong>。</p>
<h2 id=八http1x-的性能问题及优化方案>八、HTTP/1.x 的性能问题及优化方案</h2>
<p>虽然HTTP/1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。</p>
<p>比如客户端需要A、B两个资源，管道机制允许浏览器同时发出 A 请求和 B 请求，但服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为<strong>队头阻塞（<code>Head-of-line blocking</code>）</strong>。</p>
<h3 id=并发连接>并发连接</h3>
<p><strong>HTTP/1.x</strong> 可以通过对同一个域名发起多个长连接的方式提高通信效率，此种方式称为<strong>并发连接（<code>concurrent connections</code>）</strong>。</p>
<p>但是如果客户端滥用并发连接会对带宽和服务器都产生影响，一般来说，现在的浏览器支持的并发连接个数为6 ~ 8个。</p>
<h3 id=域名分片>域名分片</h3>
<p><strong>域名分片（<code>domain sharding</code>）</strong> 会将内容拆分到多个子域名中。当使用多个域名来处理多个资源时，浏览器能够同时下载更多资源，从而缩短了页面加载时间并改善了用户体验。</p>
<p>这种方式的问题在于每个域都需要额外的 DNS 查找成本以及建立每个 TCP 连接的开销。</p>
<h3 id=http2http2md><a class=link href=HTTP2.md>HTTP/2</a></h3>
<p><strong>HTTP/2</strong> 主要是为了改进 <strong>HTTP/1.x</strong> 的性能问题而产生的，在现在，<strong>不推荐使用域名分片的手段提高 HTTP 连接性能</strong>，而是直接升级到 <strong>HTTP/2</strong>。</p>
<h2 id=九https>九、HTTPS</h2>
<h3 id=http-的安全性问题>HTTP 的安全性问题</h3>
<ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<h3 id=https-概念>HTTPS 概念</h3>
<blockquote>
<p><strong>超文本传输安全协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写 <code>HTTPS</code>；常称为 HTTP over TLS、HTTP over SSL 或HTTP Secure），是一种通过计算机网络进行安全通信的协议。</p>
<p>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。</p>
<p>严格来说，<strong>HTTPS</strong> 并不是单独的协议，而是对工作在一加密连接（TLS 或 SSL）上的常规HTTP协议的称呼。</p>
</blockquote>
<h3 id=https-作用>HTTPS 作用</h3>
<h4 id=加密confidentiality>加密（Confidentiality）</h4>
<p>访问者的连接被加密，隐藏了 URL、cookie 和其他敏感的元数据</p>
<h4 id=认证authenticity>认证（Authenticity）</h4>
<p>确认访问者正在访问真实网站，而不是与冒充者或通过中间人通信</p>
<h4 id=完整性保护integrity>完整性保护（Integrity）</h4>
<p>访问者与网站之间发送的数据未被篡改或修改</p>
<h3 id=加密方式>加密方式</h3>
<p>HTTPS 采用混合加密机制</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率</li>
</ul>
<h4 id=对称密钥加密>对称密钥加密</h4>
<blockquote>
<p><strong>对称密钥加密（<code>Symmetric-Key Encryption</code>）</strong>，加密和解密使用同一密钥</p>
</blockquote>
<h4 id=非对称密钥加密>非对称密钥加密</h4>
<blockquote>
<p><strong>非对称密钥加密</strong>，又称<strong>公开密钥加密（<code>Public-Key Encryption</code>）</strong>，加密和解密使用不同的密钥</p>
</blockquote>
<h2 id=参考资料>参考资料</h2>
<ul>
<li>【日】户根勤. (2017). 网络是怎样连接的. 人民邮电出版社.</li>
<li>Kurose, J. F., & Ross, K. W. (2018). <em>计算机网络-自顶而下方法</em> (7th ed.). 机械工业出版社.</li>
<li><a class=link href=https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol target=_blank rel=noopener>Wikipedia : HTTP</a></li>
<li><a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP target=_blank rel=noopener>MDN : HTTP</a></li>
<li><a class=link href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies target=_blank rel=noopener>MDN : Cookies</a></li>
<li><a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching target=_blank rel=noopener>MDN : HTTP Caching</a></li>
<li><a class=link href=https://https.cio.gov/faq/ target=_blank rel=noopener>Introduction to HTTPS</a></li>
</ul>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a>
<a href=/tags/http/>HTTP</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>
Last updated on Jul 16, 2020 21:24 +0800
</span>
</section></footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/p/http/2/>
<div class=article-image>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211123115225.svg loading=lazy data-key data-hash=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211123115225.svg>
</div>
<div class=article-details>
<h2 class=article-title>HTTP/2</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/%E8%BF%90%E8%BE%93%E5%B1%82/>
<div class=article-image>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png loading=lazy data-key data-hash=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png>
</div>
<div class=article-details>
<h2 class=article-title>运输层</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%BA%94%E7%94%A8%E5%B1%82/>
<div class=article-details>
<h2 class=article-title>应用层</h2>
</div>
</a>
</article>
<article>
<a href=/p/ip/>
<div class=article-details>
<h2 class=article-title>IP</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>
<div class=article-details>
<h2 class=article-title>计算机网络</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src="//huanghuang's blog.disqus.com/embed.js",a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2019 -
2022 Huanghuang's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#一概述>一、概述</a>
<ol>
<li><a href=#请求和响应报文>请求和响应报文</a>
<ol>
<li><a href=#请求消息requests><strong>请求消息（<code>requests</code>）</strong></a></li>
<li><a href=#响应消息responses><strong>响应消息(<code>responses</code>)</strong></a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#二http-方法>二、HTTP 方法</a>
<ol>
<li><a href=#http方法的安全性>HTTP方法的安全性</a></li>
<li><a href=#http方法的幂等性>HTTP方法的幂等性</a></li>
</ol>
</li>
<li><a href=#三http-首部header>三、HTTP 首部（<code>header</code>)</a></li>
<li><a href=#四http-状态码status-code>四、HTTP 状态码（<code>status code</code>）</a></li>
<li><a href=#五连接管理>五、连接管理</a>
<ol>
<li><a href=#非持续连接和持续连接>非持续连接和持续连接</a>
<ol>
<li><a href=#非持续连接的问题>非持续连接的问题</a></li>
<li><a href=#持续连接的问题>持续连接的问题</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#六cookie-和-session>六、Cookie 和 Session</a>
<ol>
<li><a href=#http-cookies>HTTP Cookies</a>
<ol>
<li><a href=#用途>用途</a></li>
<li><a href=#创建过程>创建过程</a></li>
<li><a href=#生命周期>生命周期</a></li>
<li><a href=#作用域>作用域</a></li>
<li><a href=#限制访问>限制访问</a></li>
</ol>
</li>
<li><a href=#session>Session</a></li>
<li><a href=#cookie-和-session-的不同>Cookie 和 Session 的不同</a></li>
</ol>
</li>
<li><a href=#七web-缓存>七、Web 缓存</a>
<ol>
<li><a href=#缓存的种类>缓存的种类</a>
<ol>
<li><a href=#私有浏览器缓存><strong>（私有）浏览器缓存</strong></a></li>
<li><a href=#共享代理缓存><strong>（共享）代理缓存</strong></a></li>
</ol>
</li>
<li><a href=#缓存控制>缓存控制</a>
<ol>
<li><a href=#cache-control>Cache-Control</a></li>
<li><a href=#新鲜度freshness>新鲜度(<code>freshness</code>)</a></li>
<li><a href=#缓存验证validation>缓存验证(<code>validation</code>)</a></li>
</ol>
</li>
<li><a href=#强制缓存与协商缓存>强制缓存与协商缓存</a>
<ol>
<li></li>
</ol>
</li>
</ol>
</li>
<li><a href=#八http1x-的性能问题及优化方案>八、HTTP/1.x 的性能问题及优化方案</a>
<ol>
<li><a href=#并发连接>并发连接</a></li>
<li><a href=#域名分片>域名分片</a></li>
<li><a href=#http2http2md><a href=HTTP2.md>HTTP/2</a></a></li>
</ol>
</li>
<li><a href=#九https>九、HTTPS</a>
<ol>
<li><a href=#http-的安全性问题>HTTP 的安全性问题</a></li>
<li><a href=#https-概念>HTTPS 概念</a></li>
<li><a href=#https-作用>HTTPS 作用</a>
<ol>
<li><a href=#加密confidentiality>加密（Confidentiality）</a></li>
<li><a href=#认证authenticity>认证（Authenticity）</a></li>
<li><a href=#完整性保护integrity>完整性保护（Integrity）</a></li>
</ol>
</li>
<li><a href=#加密方式>加密方式</a>
<ol>
<li><a href=#对称密钥加密>对称密钥加密</a></li>
<li><a href=#非对称密钥加密>非对称密钥加密</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#参考资料>参考资料</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>