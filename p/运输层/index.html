<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主"><title>运输层</title>
<link rel=canonical href=https://huangkai1008.github.io/p/%E8%BF%90%E8%BE%93%E5%B1%82/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="运输层">
<meta property="og:description" content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主">
<meta property="og:url" content="https://huangkai1008.github.io/p/%E8%BF%90%E8%BE%93%E5%B1%82/">
<meta property="og:site_name" content="Huanghuang's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="计算机网络"><meta property="article:published_time" content="2020-08-18T09:21:31+08:00"><meta property="article:modified_time" content="2020-10-14T12:57:24+08:00"><meta property="og:image" content="https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png">
<meta name=twitter:title content="运输层">
<meta name=twitter:description content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png">
<link rel="shortcut icon" href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211018164707.jpg>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-149768628-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/p/%E8%BF%90%E8%BE%93%E5%B1%82/>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png loading=lazy alt="Featured image of post 运输层">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ style=background-color:#2a9d8f;color:#fff>
计算机网络
</a>
</header>
<h2 class=article-title>
<a href=/p/%E8%BF%90%E8%BE%93%E5%B1%82/>运输层</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 18, 2020</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
18 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=一概述>一、概述</h2>
<p>运输层协议为运行在不同主机上的应用进程之间提供了 <strong>逻辑通信（<code>logic communication</code>）</strong> 功能。</p>
<p>通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。</p>
<h3 id=端口号>端口号</h3>
<p>端口号是一个16比特的数，其大小在 0 ~ 65535 之间。</p>
<p>0 ~ 1023 范围的端口号称为 <strong>周知端口号（<code>well-known port number</code>）</strong> ，是受限制的，这些端口号一般保留给 HTTP 和 FTP 之类的周知应用层协议。</p>
<h3 id=多路复用和多路分解>多路复用和多路分解</h3>
<p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为 <strong>多路复用（<code>multiplexing</code>）</strong> 。</p>
<p>将运输层报文段中的数据交付到正确的套接字的工作称为 <strong>多路分解（<code>demultiplexing</code>）</strong> 。</p>
<h4 id=多路复用的实现>多路复用的实现</h4>
<p>运输层多路复用的要求和实现对应是：</p>
<ol>
<li>
<p>套接字有唯一标识符 &ndash; <strong>源端口号字段（<code>source port number field</code>）</strong></p>
</li>
<li>
<p>每个报文段有特殊字段来指示该报文段所要交付的字段 &ndash; <strong>目的端口号字段（<code>destination port number field</code>）</strong></p>
</li>
</ol>
<h4 id=多路分解的实现>多路分解的实现</h4>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入所连接的进程。</p>
<h2 id=二udp>二、UDP</h2>
<p>UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。</p>
<h3 id=udp-的特点>UDP 的特点</h3>
<ul>
<li>
<p><strong>UDP 是无连接的，在两个进程通信前没有握手过程。</strong> 因此 UDP 不会引入建立连接的时延。</p>
</li>
<li>
<p><strong>UDP 没有连接状态。</strong> 对应上一点提到的，因为 UDP 是无连接的，所以 UDP 不需要维护连接状态。</p>
</li>
<li>
<p><strong>UDP 提供不可靠数据服务。</strong> 当进程将一个报文发送进 UDP 套接字时，UDP 协议并不保证该报文将到达接收进程。除此之外，UDP 也不能保证报文的到达顺序，意味着到达接收进程的报文可能是乱序到达的。</p>
</li>
<li>
<p><strong>应用层控制可以做到更加精细。</strong> UDP 协议不包括拥塞控制策略，意味着 UDP 的发送端可以用选定的任意速率发送数据。应用层有着更大的实现自由，例如一些实时应用可以使用 UDP ，并作为应用的一部分来实现所需的、超出 UDP 的额外功能。</p>
</li>
<li>
<p><strong>分组首部开销小。</strong> 对比 TCP 协议有着20字节的首部开销，UDP 仅有8字节的首部开销。</p>
</li>
</ul>
<h3 id=udp-数据报结构>UDP 数据报结构</h3>
<p><strong>UDP 数据报（<code>UDP datagram</code>）</strong> 包含 <strong>报头（<code>datagram header</code>）</strong> 和 <strong>数据字段(<code>data section</code>)</strong> 两部分。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png loading=lazy alt="UDP Datagram">
</a>
<figcaption>UDP Datagram</figcaption>
</figure></p>
<h4 id=udp-协议头>UDP 协议头</h4>
<p>UDP 协议头包含4个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占16bit，即2个字节。</p>
<ul>
<li><strong>源端口（<code>source port</code>）</strong> ：可选字段，它表示发送方进程的端口号，并且应假定为在需要时要回复的端口。</li>
<li><strong>目的端口（<code>target port</code>）</strong> ：必需字段，数据报接收方的端口号。</li>
<li><strong>长度（<code>length</code>）</strong> ：协议头和数据报中数据的字节长度。最小长度为8字节，即标头的长度。</li>
<li><strong>校验和（<code>checksum</code>）</strong>：用于协议头和数据的差错检测。在IPv4中可选，在IPv6中是必需的。</li>
</ul>
<p>对于如下的一个使用 Wireshark 抓包的例子</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png loading=lazy alt="UDP header example">
</a>
<figcaption>UDP header example</figcaption>
</figure></p>
<p>上述 UDP 首部中四个字段对应的值如下：</p>
<table>
<thead>
<tr>
<th style=text-align:center>字段</th>
<th style=text-align:center>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>源端口</td>
<td style=text-align:center>0x1f5d=8029</td>
</tr>
<tr>
<td style=text-align:center>目的端口</td>
<td style=text-align:center>0x0747=1863</td>
</tr>
<tr>
<td style=text-align:center>长度</td>
<td style=text-align:center>0x0023=35</td>
</tr>
<tr>
<td style=text-align:center>校验和</td>
<td style=text-align:center>0x9019</td>
</tr>
</tbody>
</table>
<h4 id=udp-校验和>UDP 校验和</h4>
<p>UDP 校验和提供了差错检测功能，校验和用于确定当 UDP 报文段从源到目的地移动时，其中的比特是否发生了改变。</p>
<p>发送方的 UDP 对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都会被回卷，得到的结果放在校验和字段。</p>
<h2 id=三可靠数据传输>三、可靠数据传输</h2>
<p><strong>可靠数据传输协议（<code>reliable data transfer protocol</code>）</strong> 为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付。</p>
<p>我们从简单的场景渐渐过渡到复杂的场景，看如何实现可靠数据传输协议。</p>
<h3 id=1-经完全可靠信道的可靠数据传输10>1. 经完全可靠信道的可靠数据传输：1.0</h3>
<p>在这个场景下，我们假设底层信道是完全可靠的，并且接收端的接收速率可以和发送端的发送速率同步。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg loading=lazy alt="rdt 1.0 fsm">
</a>
<figcaption>rdt 1.0 fsm</figcaption>
</figure></p>
<p>rdt 1.0 发送端在收到发送数据的事件（<code>rdt_send(data)</code>） 后，把数据分割成一个个分组，并开始发送数据。</p>
<p>rdt 1.0 接收端在收到接收数据的事件（<code>rdt_rcv(packet)</code>）后，从分组中提取数据，并把数据发送给上层。</p>
<h3 id=2-经具有比特差错信道的可靠数据传输20>2. 经具有比特差错信道的可靠数据传输：2.0</h3>
<p>底层信道更为实际的模型是分组中的比特可能受损的模型。在这个场景下，我们还是假设发送的分组依然按序交付。</p>
<h4 id=arq-协议的定义>ARQ 协议的定义</h4>
<p>在生活中两人打电话的场景也和此场景相近。假设 A 和 B 正在通电话，如果 A 说完一段话后，B 清楚地听到后会回复“好的”，如果 B 觉得 A 讲得含混不清，B 会回复 A “请重复一遍，我没听清”。回复“好的”可以视为 <strong>肯定确认（<code>positive acknowledgment</code>）</strong> ，回复“请重复一遍，我没听清楚”可以视为 <strong>否定确认（<code>negative acknowledgment</code>）</strong> 。</p>
<p>接收端可以通过这种方式使得发送端知道哪些内容被正确接收，哪些内容接收有误并需要重传。在计算机网络环境中，基于这种机制的可靠数据传输协议称为 <strong>自动重传请求（<code>Automatic Repeat reQuest, ARQ</code>）协议</strong> 。</p>
<h4 id=arq-协议的实现>ARQ 协议的实现</h4>
<p>ARQ 协议需要三种协议功能来实现。</p>
<ul>
<li>
<p><strong>差错检测</strong>
和 UDP 的<a class=link href=%e8%bf%90%e8%be%93%e5%b1%82.md#UDP%20%e6%a0%a1%e9%aa%8c%e5%92%8c>校验和</a>功能实现类似，我们可以通过增加校验和字段的方式来实现差错检测。</p>
</li>
<li>
<p><strong>接收方反馈</strong>
在通电话场景下的 ACK （肯定确认） 和 NAK （否定确认）可以实现接收方反馈的功能。</p>
</li>
<li>
<p><strong>重传</strong>
接收方收到有差错的分组时，发送方将重传该分组。</p>
</li>
</ul>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg loading=lazy alt="rdt 2.0 fsm">
</a>
<figcaption>rdt 2.0 fsm</figcaption>
</figure></p>
<p>当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，也即此时<code>rdt_send</code>事件不会发生。因此，除非发送端确认接收端已经正确地收到它当前发送的数据，发送端是不会发送新数据的。实现此类行为特征的协议被称为 <strong>停等协议（<code>stop-and-wait protocol</code>）</strong> 。</p>
<h4 id=处理acknak分组受损的场景>处理ACK/NAK分组受损的场景</h4>
<p>rdt 2.0 的实现没有考虑ACK或者NAK分组受损的可能性，在这种场景下，发送端无法知道接收端是否成功接收了上一块发送的数据。</p>
<p>我们的解决方案是在数据分组中增加一个新字段，让发送端对其数据分组编号，即将发送数据分组的 <strong>序列号（<code>sequence number</code>）</strong> 放在该字段。</p>
<p>rdt 2.0 作为停止等待协议的一个简单实现，序列号的长度是1位就够了。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg loading=lazy alt="rdt 2.1 sender fsm">
</a>
<figcaption>rdt 2.1 sender fsm</figcaption>
</figure></p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg loading=lazy alt="rdt 2.1 receiver fsm">
</a>
<figcaption>rdt 2.1 receiver fsm</figcaption>
</figure></p>
<p>rdt 2.1 在发送端和接收端均使用了 ACK/NAK，当接收端收到失序分组时，接收端发送 ACK 。当受损分组到达接收端时，接收端发送 NAK。</p>
<p>rdt 2.2 要做的改进是当受损分组到达接收端时，接收端不发送 NAK，取而代之的是发送一个对最近正确收到的数据的 ACK 。这时需要给 ACK 分组也添加序列号，当发送端收到这个 ACK 时，发送端可以根据 ACK 分组的序列号去判断这个 ACK 分组代表的是接收端正确接收了它刚发送的数据亦或是接收端正确接受了它上一次发送的数据。
当发送端收到两个对同一个分组确认的 ACK 时，即收到重复的 ACK ，发送端就可以知道接收端未能正确收到被确认两次的分组的下一个分组。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg loading=lazy alt="rdt 2.2 sender fsm">
</a>
<figcaption>rdt 2.2 sender fsm</figcaption>
</figure></p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg loading=lazy alt="rdt 2.2 receiver fsm">
</a>
<figcaption>rdt 2.2 receiver fsm</figcaption>
</figure></p>
<h3 id=3-经具有比特差错的丢包信道的可靠数据运输30>3. 经具有比特差错的丢包信道的可靠数据运输：3.0</h3>
<p>这个场景下底层信道不但会产生比特受损外，还会有丢包的现象。所以协议现在必须处理另外两个关注的问题：</p>
<ol>
<li>怎么检测丢包</li>
<li>发生丢包后如何处理</li>
</ol>
<p>发送端可以选择一个合理的时间值，如果在这个时间段内，它没有收到这个分组的 ACK ，则重传该分组。即使在这种情况下引入了 <strong>冗余数组分组（<code>duplicate data packet</code>）</strong> 的可能性，但是 rdt 2.2 已经使用序列号处理冗余分组的情况。</p>
<p>实现基于时间的重传机制，需要一个 <strong>倒计数定时器（<code>countdown timer</code>）</strong> ，在一个给定的时间量过期后，可中断发送端。因此发送端需要以下功能：</p>
<ol>
<li>每次发送一个分组（包括第一次分组和重传分组），便启动一个定时器</li>
<li>响应定时器中断（采取适当的动作）</li>
<li>终止定时器</li>
</ol>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg loading=lazy alt="rdt 3.0 fsm sender">
</a>
<figcaption>rdt 3.0 fsm sender</figcaption>
</figure></p>
<p>因为分组序号在0和1之间交替，所以 rdt 3.0有时候被称为 <strong>比特交替协议（<code>alternating-bit protocol</code>）</strong> 。</p>
<h3 id=4-流水线可靠数据传输协议>4. 流水线可靠数据传输协议</h3>
<p>rdt 3.0 采用的是停等协议，这样会导致信道的利用率很低，性能会非常差。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg loading=lazy alt="pipelined protocol vs Stop-and-wait protocol">
</a>
<figcaption>pipelined protocol vs Stop-and-wait protocol</figcaption>
</figure></p>
<p>可以使用 <strong>流水线（<code>pipelining</code>)</strong> 技术使得分组可以同时发送，以提高性能。实现流水线技术的要点有：</p>
<ol>
<li><strong>序列号的范围需要增加</strong>，因为每个传送途中（非重传）的分组需要独一无二的序列号，而且同时可能存在多个在传送的未确认报文。</li>
<li><strong>发送端和接收端可能需要缓存多个分组</strong>，发送端至少需要缓存那些已发送但是还未确认的分组，接收端可能需要缓存那些已经正确接收的分组。</li>
<li>所需序列号范围和缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种基本方法：
a. <strong>回退 N 步（<code>Go-Back-N, GBN</code>）</strong>
b. <strong>选择重传（<code>Selective Repeat, SR</code>）</strong></li>
</ol>
<h4 id=回退n步>回退N步</h4>
<p>在 GBN 协议中，发送端可以在不需要等待收到 ACK 的情况下，同时发送 N 个分组，这意味着发送端最多能保持 N 个未收到 ACK 的分组，N 也被称为滑动窗口的大小。GBN 协议也常被称为 <strong>滑动窗口协议（<code>sliding-window protocol</code>）</strong> 。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063778631352.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063778631352.jpeg loading=lazy alt="Sender&rsquo;s view of sequence numbers in Go-Back-N">
</a>
<figcaption>Sender’s view of sequence numbers in Go-Back-N</figcaption>
</figure></p>
<p><code>base</code> 定义为最小的未收到 ACK 的分组的序列号，<code>nextseqnum</code> 定义为下一个将被发送的分组的序列号。</p>
<p>区间 [0, base - 1] 定义为已经发送并且已经收到 ACK 的分组序列号。
区间 [base, nextseqnum - 1] 定义为已经发送但是还未收到 ACK 的分组序列号。
区间 [nextseqnum, base + N - 1] 定义为那些要被立刻发送的分组序列号。
区间 [base + N, +∞] 定义为待发送的分组序列号，需要等到序列号为 base 的分组收到 ACK 后，整个滑动窗口向前滑动，base + N 的分组才能被发送。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184244495>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184244495 loading=lazy alt="GBN sender">
</a>
<figcaption>GBN sender</figcaption>
</figure></p>
<p>当发送端的上层调用 <code>rdt_send()</code> 时，发送端首先会检查发送窗口是否已满，如果窗口已满，则拒绝发送分组。当超时事件发生时，发送端启动定时器，且会重新发送所有之前已发送过但未收到 ACK 的分组(即区间 [base, nextseqnum - 1]内的分组）。</p>
<p>当收到某个分组的 ACK 时，还有已被发送且未收到 ACK 的分组，发送端需要重启定时器。如果没有已发送但未被确认的分组，停止该计时器。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184357967>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184357967 loading=lazy alt="GBN receiver">
</a>
<figcaption>GBN receiver</figcaption>
</figure></p>
<p>假设接收端已经接收到前 n - 1 个分组，那么接收端下一个期待的待接收分组的序列号就为 n 。接收端会丢弃所有下一个到来的序列号非 n 的分组，并重新发送最近收到的分组的 ACK （在这个例子中为：ACK n - 1）。GBN 在这种场景下使用 <strong>累积确认（<code>cumulative acknowledgments</code>）</strong> 。</p>
<h4 id=选择重传>选择重传</h4>
<p>GBN 协议潜在地允许发送方用多个分组 “填充流水线” ，因此避免了停等协议中所提到的信道利用率问题。然而 GBN 本身也存在着性能问题，特别是当前网络的带宽延时乘积和滑动窗口 N 都很大时，单个分组的出错就会引起 GBN 重传大量分组，这在大部分情况是没有必要的。随着信道差错率的增加，滑动窗口中便会塞满大量重传的分组。</p>
<p>顾名思义，选择重传协议只会重传一些接收端未正确收到的分组。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。与 GBN 不同的是，它的滑动窗口中会包含一些被 ACK 过的分组。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063950129010.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063950129010.jpeg loading=lazy alt="选择重传（SR) 发送端与接收端的序号空间">
</a>
<figcaption>选择重传（SR) 发送端与接收端的序号空间</figcaption>
</figure></p>
<p>SR 接收端将确认一个正确接收的分组而不管其是否是按序的。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）都被收到为止。例如发送端发送了5个分组，序列号分别为 {0, 1, 2, 3, 4}，但是分组 0 丢失了，其它4个分组被成功接收。那么这4个分组将被接收端缓存，并且发送相应的 ACK 给发送端，然后等待分组0，当分组0重传并且成功收到后，接收端将会把这5个分组一起交付给上层。</p>
<p>SR 协议中发送端的事件与动作包括：</p>
<ol>
<li><strong>从上层收到数据</strong> 。当从上层接收到数据后，SR 发送端检查下一个可用于该分组的序号。如果序号位于发送端的滑动窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将分组缓存，要么将其返回给上层以便以后传输。</li>
<li><strong>超时</strong> 。这里再次使用定时器防止丢失分组。在这个场景下需要每个分组拥有自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作。</li>
<li><strong>收到 ACK</strong> 。如果收到 ACK ，倘若该分组序号在窗口内，则 SR 发送端将那个被确认的分组标记为已接收。如果该分组的序号等于 <code>send_base</code> ，则窗口基序号向前移动到具有最小序号的未确定分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li>
</ol>
<p>SR 协议中接收端的事件与动作包括：</p>
<ol>
<li><strong>序号在 [rcv_base, rcv_base + N - 1] 内的分组被正确接收。</strong> 在此情况下，收到的分组落在接收端的窗口内，一个选择 ACK 被会送给发送端。如果该分组以前未被收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（<code>rcv_base</code>） ，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li>
<li><strong>序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收。</strong> 在此情况下，必须产生一个 ACK ，即使该分组是接收端以前已经确认过的分组。</li>
<li><strong>其他情况。</strong> 忽略该分组。</li>
</ol>
<p><strong>值得注意的是，对于 SR 协议而言，窗口大小必须小于等于序号空间大小的一半。</strong></p>
<h2 id=四tcp>四、TCP</h2>
<h3 id=tcp-的特点>TCP 的特点</h3>
<h4 id=面向连接>面向连接</h4>
<p>TCP 是 <strong>面向连接的（<code>connection-oriented</code>）</strong> ，即在一个应用进程在向另一个应用进程发送数据之前，这两个进程必须要相互<strong>握手（<code>handshake</code>）</strong> 。握手的意思是它们相互发送某些预备报文段，以建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态变量。</p>
<p>值得注意的是，TCP 连接指的不是一条像在<a class=link href=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c.md#%e7%94%b5%e8%b7%af%e4%ba%a4%e6%8d%a2%ef%bc%88%20circuit%20switching%20%ef%bc%89>电路交换</a>网络中的端到端 TDM 或 FDM 电路。<strong>这里的 “连接” 是一条逻辑连接，其共同状态仅保留在两个通信端系统的 TCP 程序中。</strong></p>
<h4 id=全双工服务>全双工服务</h4>
<p>TCP 连接提供的是 <strong>全双工服务（<code>full-duplex service</code>）</strong> , 如果一台主机上的进程 B 存在一条 TCP 连接，那么应用层数据就可在从进程 B 流向 进程 A 的同时，也从进程 A 流向 进程 B。</p>
<h4 id=点对点通信>点对点通信</h4>
<p>TCP 连接总是 <strong>点对点的（<code>point-to-point</code>）</strong> ，即 TCP 连接总存在于单个发送方和单个接收方之间。</p>
<h4 id=面向字节流>面向字节流</h4>
<p>TCP 把数据看作一个无结构的、有序的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给予确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。</p>
<p>TCP 可从缓存中取出并放入报文段中的数据数量受限于 <strong>最大报文段长度（<code>Maximum Segment Size, MSS</code>）</strong> 。</p>
<h3 id=tcp-的组成>TCP 的组成</h3>
<p>TCP 连接包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</p>
<h3 id=tcp-报文段结构>TCP 报文段结构</h3>
<p><strong>TCP 报文段（<code>TCP segment</code>）</strong> 包含 <strong>报文首部（<code>segment header</code>）</strong> 和 <strong>数据字段（<code>data section</code>）</strong> 两部分。</p>
<h4 id=tcp-报文首部>TCP 报文首部</h4>
<p>TCP 报文首部和<a class=link href=#UDP%20%e5%8d%8f%e8%ae%ae%e5%a4%b4>UDP 协议头</a>一样包含以下字段：</p>
<ul>
<li><strong>源端口（<code>source port</code>）</strong></li>
<li><strong>目的端口（<code>target port</code>）</strong></li>
<li><strong>校验和（<code>checksum</code>）</strong></li>
</ul>
<p>除此以外 TCP 报文首部还包含以下字段：</p>
<ul>
<li><strong>序号（<code>sequence number</code>）</strong> 和 <strong>确认号（<code>acknowledgment number</code>）</strong> ：长度都是32bit，被 TCP 发送方和接收方用于实现可靠数据传输服务。</li>
<li><strong>窗口大小（<code>receive window size</code>）</strong> ：接收窗口的大小，长度为16bit，此字段指示接收方愿意接受的字节数量。</li>
<li><strong>首部长度（<code>Data offset</code>）</strong>：长度为4bit，以32bit为单位计算出的数据段开始地址的偏移值。</li>
<li><strong>选项（<code>options</code>）</strong>：可选、不定长字段，该字段用于发送方和接收方协商最大报文段长度（<code>MSS</code>）时，或在高速网络环境下用作窗口调节因子。</li>
<li><strong>标志（<code>flag</code>）</strong>：长度为9bit，其中每个bit都是一个控制位。
<ul>
<li>SYN，为同步标志，用于数据同步；</li>
<li>ACK，为确认序号，ACK=1时确认号才有效；</li>
<li>FIN，为结束序号，用于发送端提出断开连接；</li>
<li>URG，为紧急序号，URG=1是紧急指针有效；</li>
<li>PSH，指示接收方立即将数据提交给应用层，而不是等待缓冲区满；</li>
<li>RST，重置连接；</li>
<li>NS，该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害；</li>
<li>ECE，ECN表示<code>Explicit Congestion Notification</code>，表示TCP peer有ECN能力；</li>
<li>CWR，发送者在接收到一个带有ECE flag包时，将会使用CWR 标志。</li>
</ul>
</li>
</ul>
<h5 id=序号和确认号>序号和确认号</h5>
<p>TCP 是<a class=link href=%e8%bf%90%e8%be%93%e5%b1%82.md#%e9%9d%a2%e5%90%91%e5%ad%97%e8%8a%82%e6%b5%81>面向字节流</a>的，序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上，因此 <strong>一个报文段的序号（<code>sequence number for a segment</code>）</strong> 是该报文段首字节的字节流编号。</p>
<p>假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流。主机中的 TCP 将隐式地对数据流中的每一个字节编号。假定数据流由一个包含 500, 000字节的文件组成，其 MSS 为1000字节，数据流的首字节编号是 <code>X</code> ，那么该 TCP 实体将为该数据流构建500个报文段，给第一个报文段分配序号 <code>X</code> ，给第二个报文段分配序号 <code>X + MSS * 1</code>，第 N 个报文段分配序号 <code>X + MSS * (N - 1)</code> 。</p>
<p>从上面例子可以看到，TCP 的确认号从一个随机的值开始，<strong>这是为了提高安全性，也可以避免被相同端点之间早期连接的旧报文段混淆</strong>。</p>
<p><strong>确认号是期望从另一方收到的下一个字节的序号</strong>。与上文我们讨论的 rdt 不同的是，这里的确认号<strong>多加了1</strong>。</p>
<p>例如主机 A 已收到 一个来自主机 B 的包含字节 0 ~ 535 的报文段，以及另一个包含字节 900 ~ 1000 的报文段。由于某种原因，主机 A 还没有收到字节 536 ~ 899 的报文段。在这个例子中，主机 A 为了重新构建主机 B 的数据流，仍在等待字节 536 和其后的字节。因此，A 到 B 的下一个报文段将在确认号中包含 536。因为 TCP 只确认该流中至第一个丢失字节为止的字节，所以 TCP 被称为提供 <strong>累积确认（<code>cumulative acknowledement</code>）</strong> ，在这里和 <a class=link href=%e8%bf%90%e8%be%93%e5%b1%82.md#%e5%9b%9e%e9%80%80N%e6%ad%a5>GBN</a> 协议有些相似。</p>
<h3 id=tcp-可靠数据传输的实现>TCP 可靠数据传输的实现</h3>
<p>TCP 在 IP 不可靠的服务上创建了可靠数据传输服务。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。</p>
<h4 id=tcp-发送方事件>TCP 发送方事件</h4>
<p>TCP 发送方的三个主要事件分别是</p>
<ol>
<li>从应用层接收数据。</li>
<li>超时。</li>
<li>收到确认。</li>
</ol>
<p>TCP 通过超时和重复确认两个事件触发重传。</p>
<p>当定时器超时，TCP 重传具有最小序号但仍未应答的报文段，此表现和 SR 协议相似。
当 TCP 收到多个重复的确认时，TCP 会执行<a class=link href=%e8%bf%90%e8%be%93%e5%b1%82.md#%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0>快速重传</a>。</p>
<h4 id=快速重传>快速重传</h4>
<p>超时重传的问题之一是超时周期可能相对较长，会增加端到端时延。</p>
<p>我们通过冗余的 ACK 来检测报文段丢失，如果发送方接收到对于相同数据的3个冗余ACK，这说明跟在这个已被确认过三次的报文段之后的报文段很大可能已经丢失。我们在这种情况下执行 <strong>快速重传（<code>fast retransmit</code>）</strong> ，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<h3 id=tcp-流量控制>TCP 流量控制</h3>
<p>TCP 提供了 <strong>流量控制服务（<code>flow-control service</code>）</strong> 以消除发送方使接收方缓存溢出的可能性。</p>
<h3 id=tcp-连接管理>TCP 连接管理</h3>
<h4 id=tcp-建立连接>TCP 建立连接</h4>
<p>TCP 连接的创建过程通常被称为 <strong>三次握手（<code>three-way handshake</code>）</strong>。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png loading=lazy alt="TCP 三次握手">
</a>
<figcaption>TCP 三次握手</figcaption>
</figure></p>
<p>一般地，客户端和服务端开始都处于 <code>CLOSED</code> 状态，服务端主动监听某个端口，状态变更为 <code>LISTEN</code> 状态。</p>
<p>第一步，客户端会发送一个 <strong>SYN 报文段</strong>。此报文段的 <code>SYN</code> 标志位置为 <strong>1</strong>，首部的序号字段由随机的初始序号（<code>client_isn</code>）填充，此报文段不包含任何应用层数据。在此报文段发送后，客户端 TCP 状态会变更到 <code>SYN_SENT</code>。</p>
<p>第二步，当服务端收到客户端的 <strong>SYN 报文段</strong> 后，服务端会为该 TCP 连接分配 TCP 缓存和变量， 并发送一个 <strong>SYNACK报文段</strong> 表达对连接请求的允许。此报文段的 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <strong>1</strong> ，首部的序号字段由随机的初始序号（<code>server_isn</code>）填充，首部的确认号字段填入客户端的初始序号 + 1 （<code>client_isn + 1</code>），这个报文段也不包含任何应用层数据。在此报文段发送后，服务端 TCP 状态会变更到 <code>SYN_RCVD</code>。</p>
<p>第三步，在客户端收到 <strong>SYNACK报文段</strong> 后，客户端也需要为此 TCP 连接分配 TCP 缓存和变量，并发送一个应答报文对服务器的允许连接报文段进行了确认。此报文段的<code>ACK</code> 标志位置为 <strong>1</strong> ，<code>SYN</code> 标志位置为1，首部的序号字段是<code>client_isn + 1</code>，确认号字段是<code>server_isn + 1</code>。<strong>注意，此报文段可以携带应用层数据</strong>。发送此报文段后，客户端状态会变更为 <code>ESTABLISHED</code>，在服务端接收到此报文段后，服务端状态也会变更为 <code>ESTABLISHED</code>。</p>
<h4 id=tcp-关闭连接>TCP 关闭连接</h4>
<p>连接双方都可以主动断开连接，断开连接后主机中的资源（即缓存和变量）将被释放。TCP 断开连接的方式通常被称为 <strong>四次挥手（<code>four-way handshake</code>）</strong>。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png loading=lazy alt="TCP 四次挥手">
</a>
<figcaption>TCP 四次挥手</figcaption>
</figure></p>
<p>假设 TCP 客户端想要断开连接，它会发送一个 <strong>FIN 报文段</strong> ，此报文段的 <code>FIN</code> 标志位置为1，此后客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
<p>服务端收到客户端的 <strong>FIN 报文段</strong> 后，就会向客户端发送 <strong>ACK 报文段</strong> ，此后服务端进入 <code>CLOSED_WAIT</code> 状态。客户端收到服务端的此 <strong>ACK 报文段</strong> 后，会进入 <code>FIN_WAIT_2</code> 状态。</p>
<p>等待服务端处理数据完成后，服务端会发送它自己的 <strong>FIN 报文段</strong> ，发送后服务端进入 <code>LAST_ACK</code> 阶段。客户端收到服务端的 <strong>FIN 报文段</strong> 后，客户端会回复自己的 <strong>ACK 报文段</strong> ，之后客户端进入 <code>TIME_WAIT</code> 状态。</p>
<p>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭，客户端在经过 <code>2MSL</code> 时间后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</p>
<h5 id=time_wait-状态的必要性>TIME_WAIT 状态的必要性</h5>
<p><strong>MSL(<code>Maximum Segment Lifetime</code>)</strong> 是 <strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p><code>TIME_WAIT</code> 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以 <strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>关于为什么 TCP 有 TIME_WAIT 状态，最主要的原因应该是 <strong>保证连接关闭</strong> 。只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。</p>
<hr>
<h2 id=参考资料>参考资料</h2>
<ul>
<li>Kurose, J. F., & Ross, K. W. (2018). <em>计算机网络-自顶而下方法</em> (7th ed.). 机械工业出版社.</li>
<li><a class=link href=https://en.wikipedia.org/wiki/User_Datagram_Protocol target=_blank rel=noopener>Wikipedia : User Datagram Protocol</a></li>
<li><a class=link href=https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html target=_blank rel=noopener>Go-Back-N Protocol</a></li>
<li><a class=link href=https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html target=_blank rel=noopener>Selective Repeat Protocol</a></li>
<li><a class=link href=https://en.wikipedia.org/wiki/Transmission_Control_Protocol target=_blank rel=noopener>Wikipedia : Transmission Control Protocol</a></li>
<li><a class=link href=https://draveness.me/whys-the-design-tcp-time-wait/ target=_blank rel=noopener>为什么 TCP 协议有 TIME_WAIT 状态</a></li>
</ul>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>MIT</span>
</section>
<section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>
Last updated on Oct 14, 2020 12:57 +0800
</span>
</section></footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/p/http/2/>
<div class=article-image>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211123115225.svg loading=lazy data-key data-hash=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211123115225.svg>
</div>
<div class=article-details>
<h2 class=article-title>HTTP/2</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%BA%94%E7%94%A8%E5%B1%82/>
<div class=article-details>
<h2 class=article-title>应用层</h2>
</div>
</a>
</article>
<article>
<a href=/p/ip/>
<div class=article-details>
<h2 class=article-title>IP</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>
<div class=article-details>
<h2 class=article-title>计算机网络</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%9F%9F%E5%90%8D%E5%92%8Cdns/>
<div class=article-details>
<h2 class=article-title>域名和DNS</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src="//huanghuang's blog.disqus.com/embed.js",a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2019 -
2022 Huanghuang's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#一概述>一、概述</a>
<ol>
<li><a href=#端口号>端口号</a></li>
<li><a href=#多路复用和多路分解>多路复用和多路分解</a>
<ol>
<li><a href=#多路复用的实现>多路复用的实现</a></li>
<li><a href=#多路分解的实现>多路分解的实现</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#二udp>二、UDP</a>
<ol>
<li><a href=#udp-的特点>UDP 的特点</a></li>
<li><a href=#udp-数据报结构>UDP 数据报结构</a>
<ol>
<li><a href=#udp-协议头>UDP 协议头</a></li>
<li><a href=#udp-校验和>UDP 校验和</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#三可靠数据传输>三、可靠数据传输</a>
<ol>
<li><a href=#1-经完全可靠信道的可靠数据传输10>1. 经完全可靠信道的可靠数据传输：1.0</a></li>
<li><a href=#2-经具有比特差错信道的可靠数据传输20>2. 经具有比特差错信道的可靠数据传输：2.0</a>
<ol>
<li><a href=#arq-协议的定义>ARQ 协议的定义</a></li>
<li><a href=#arq-协议的实现>ARQ 协议的实现</a></li>
<li><a href=#处理acknak分组受损的场景>处理ACK/NAK分组受损的场景</a></li>
</ol>
</li>
<li><a href=#3-经具有比特差错的丢包信道的可靠数据运输30>3. 经具有比特差错的丢包信道的可靠数据运输：3.0</a></li>
<li><a href=#4-流水线可靠数据传输协议>4. 流水线可靠数据传输协议</a>
<ol>
<li><a href=#回退n步>回退N步</a></li>
<li><a href=#选择重传>选择重传</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#四tcp>四、TCP</a>
<ol>
<li><a href=#tcp-的特点>TCP 的特点</a>
<ol>
<li><a href=#面向连接>面向连接</a></li>
<li><a href=#全双工服务>全双工服务</a></li>
<li><a href=#点对点通信>点对点通信</a></li>
<li><a href=#面向字节流>面向字节流</a></li>
</ol>
</li>
<li><a href=#tcp-的组成>TCP 的组成</a></li>
<li><a href=#tcp-报文段结构>TCP 报文段结构</a>
<ol>
<li><a href=#tcp-报文首部>TCP 报文首部</a></li>
</ol>
</li>
<li><a href=#tcp-可靠数据传输的实现>TCP 可靠数据传输的实现</a>
<ol>
<li><a href=#tcp-发送方事件>TCP 发送方事件</a></li>
<li><a href=#快速重传>快速重传</a></li>
</ol>
</li>
<li><a href=#tcp-流量控制>TCP 流量控制</a></li>
<li><a href=#tcp-连接管理>TCP 连接管理</a>
<ol>
<li><a href=#tcp-建立连接>TCP 建立连接</a></li>
<li><a href=#tcp-关闭连接>TCP 关闭连接</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#参考资料>参考资料</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>