<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主"><title>运输层</title>
<link rel=canonical href=https://huangkai1008.github.io/p/%E8%BF%90%E8%BE%93%E5%B1%82/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="运输层">
<meta property="og:description" content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主">
<meta property="og:url" content="https://huangkai1008.github.io/p/%E8%BF%90%E8%BE%93%E5%B1%82/">
<meta property="og:site_name" content="Huanghuang's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="计算机网络"><meta property="article:published_time" content="2020-08-18T09:21:31+08:00"><meta property="article:modified_time" content="2020-09-01T22:13:24+08:00">
<meta name=twitter:title content="运输层">
<meta name=twitter:description content="一、概述 运输层协议为运行在不同主机上的应用进程之间提供了 逻辑通信（logic communication） 功能。 通过逻辑通信，运行不同进程的主">
<link rel="shortcut icon" href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20211018164707.jpg>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-149768628-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ style=background-color:#2a9d8f;color:#fff>
计算机网络
</a>
</header>
<h2 class=article-title>
<a href=/p/%E8%BF%90%E8%BE%93%E5%B1%82/>运输层</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 18, 2020</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
7 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=一概述>一、概述</h2>
<p>运输层协议为运行在不同主机上的应用进程之间提供了 <strong>逻辑通信（<code>logic communication</code>）</strong> 功能。</p>
<p>通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。</p>
<h3 id=端口号>端口号</h3>
<p>端口号是一个16比特的数，其大小在 0 ~ 65535 之间。</p>
<p>0 ~ 1023 范围的端口号称为 <strong>周知端口号（<code>well-known port number</code>）</strong> ，是受限制的，这些端口号一般保留给 HTTP 和 FTP 之类的周知应用层协议。</p>
<h3 id=多路复用和多路分解>多路复用和多路分解</h3>
<p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为 <strong>多路复用（<code>multiplexing</code>）</strong> 。</p>
<p>将运输层报文段中的数据交付到正确的套接字的工作称为 <strong>多路分解（<code>demultiplexing</code>）</strong> 。</p>
<h4 id=多路复用的实现>多路复用的实现</h4>
<p>运输层多路复用的要求和实现对应是：</p>
<ol>
<li>
<p>套接字有唯一标识符 &ndash; <strong>源端口号字段（<code>source port number field</code>）</strong></p>
</li>
<li>
<p>每个报文段有特殊字段来指示该报文段所要交付的字段 &ndash; <strong>目的端口号字段（<code>destination port number field</code>）</strong></p>
</li>
</ol>
<h4 id=多路分解的实现>多路分解的实现</h4>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入所连接的进程。</p>
<h2 id=二udp>二、UDP</h2>
<p>UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。</p>
<h3 id=udp-的特点>UDP 的特点</h3>
<ul>
<li>
<p><strong>UDP 是无连接的，在两个进程通信前没有握手过程。</strong> 因此 UDP 不会引入建立连接的时延。</p>
</li>
<li>
<p><strong>UDP 没有连接状态。</strong> 对应上一点提到的，因为 UDP 是无连接的，所以 UDP 不需要维护连接状态。</p>
</li>
<li>
<p><strong>UDP 提供不可靠数据服务。</strong> 当进程将一个报文发送进 UDP 套接字时，UDP 协议并不保证该报文将到达接收进程。除此之外，UDP 也不能保证报文的到达顺序，意味着到达接收进程的报文可能是乱序到达的。</p>
</li>
<li>
<p><strong>应用层控制可以做到更加精细。</strong> UDP 协议不包括拥塞控制策略，意味着 UDP 的发送端可以用选定的任意速率发送数据。应用层有着更大的实现自由，例如一些实时应用可以使用 UDP ，并作为应用的一部分来实现所需的、超出 UDP 的额外功能。</p>
</li>
<li>
<p><strong>分组首部开销小。</strong> 对比 TCP 协议有着20字节的首部开销，UDP 仅有8字节的首部开销。</p>
</li>
</ul>
<h3 id=udp-数据报结构>UDP 数据报结构</h3>
<p><strong>UDP 数据报（<code>UDP datagram</code>）</strong> 包含 <strong>报头（<code>datagram header</code>）</strong> 和 <strong>数据字段(<code>data section</code>)</strong> 两部分。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png loading=lazy alt="UDP Datagram">
</a>
<figcaption>UDP Datagram</figcaption>
</figure></p>
<h4 id=udp-协议头>UDP 协议头</h4>
<p>UDP 协议头包含4个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占16bit，即2个字节。</p>
<ul>
<li><strong>源端口</strong> ：可选字段，它表示发送方进程的端口号，并且应假定为在需要时要回复的端口。</li>
<li><strong>目的端口</strong> ：必需字段，数据报接收方的端口号。</li>
<li><strong>长度</strong> ：协议头和数据报中数据的字节长度。最小长度为8字节，即标头的长度。</li>
<li><strong>校验和</strong>：用于协议头和数据的差错检测。在IPv4中可选，在IPv6中是必需的。</li>
</ul>
<p>对于如下的一个使用 Wireshark 抓包的例子</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png loading=lazy alt="UDP header example">
</a>
<figcaption>UDP header example</figcaption>
</figure></p>
<p>上述 UDP 首部中四个字段对应的值如下：</p>
<table>
<thead>
<tr>
<th style=text-align:center>字段</th>
<th style=text-align:center>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>源端口</td>
<td style=text-align:center>0x1f5d=8029</td>
</tr>
<tr>
<td style=text-align:center>目的端口</td>
<td style=text-align:center>0x0747=1863</td>
</tr>
<tr>
<td style=text-align:center>长度</td>
<td style=text-align:center>0x0023=35</td>
</tr>
<tr>
<td style=text-align:center>校验和</td>
<td style=text-align:center>0x9019</td>
</tr>
</tbody>
</table>
<h4 id=udp-校验和>UDP 校验和</h4>
<p>UDP 校验和提供了差错检测功能，校验和用于确定当 UDP 报文段从源到目的地移动时，其中的比特是否发生了改变。</p>
<p>发送方的 UDP 对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都会被回卷，得到的结果放在校验和字段。</p>
<h2 id=三可靠数据传输>三、可靠数据传输</h2>
<p><strong>可靠数据传输协议（<code>reliable data transfer protocol</code>）</strong> 为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付。</p>
<p>我们从简单的场景渐渐过渡到复杂的场景，看如何实现可靠数据传输协议。</p>
<h3 id=1-经完全可靠信道的可靠数据传输10>1. 经完全可靠信道的可靠数据传输：1.0</h3>
<p>在这个场景下，我们假设底层信道是完全可靠的，并且接收端的接收速率可以和发送端的发送速率同步。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg loading=lazy alt="rdt 1.0 fsm">
</a>
<figcaption>rdt 1.0 fsm</figcaption>
</figure></p>
<p>rdt 1.0 发送端在收到发送数据的事件（<code>rdt_send(data)</code>） 后，把数据分割成一个个分组，并开始发送数据。</p>
<p>rdt 1.0 接收端在收到接收数据的事件（<code>rdt_rcv(packet)</code>）后，从分组中提取数据，并把数据发送给上层。</p>
<h3 id=2-经具有比特差错信道的可靠数据传输20>2. 经具有比特差错信道的可靠数据传输：2.0</h3>
<p>底层信道更为实际的模型是分组中的比特可能受损的模型。在这个场景下，我们还是假设发送的分组依然按序交付。</p>
<h4 id=arq-协议的定义>ARQ 协议的定义</h4>
<p>在生活中两人打电话的场景也和此场景相近。假设 A 和 B 正在通电话，如果 A 说完一段话后，B 清楚地听到后会回复“好的”，如果 B 觉得 A 讲得含混不清，B 会回复 A “请重复一遍，我没听清”。回复“好的”可以视为 <strong>肯定确认（<code>positive acknowledgment</code>）</strong> ，回复“请重复一遍，我没听清楚”可以视为 <strong>否定确认（<code>negative acknowledgment</code>）</strong> 。</p>
<p>接收端可以通过这种方式使得发送端知道哪些内容被正确接收，哪些内容接收有误并需要重传。在计算机网络环境中，基于这种机制的可靠数据传输协议称为 <strong>自动重传请求（<code>Automatic Repeat reQuest, ARQ</code>）协议</strong> 。</p>
<h4 id=arq-协议的实现>ARQ 协议的实现</h4>
<p>ARQ 协议需要三种协议功能来实现。</p>
<ul>
<li>
<p><strong>差错检测</strong>
和 UDP 的<a class=link href=%e8%bf%90%e8%be%93%e5%b1%82.md#UDP%20%e6%a0%a1%e9%aa%8c%e5%92%8c>校验和</a>功能实现类似，我们可以通过增加校验和字段的方式来实现差错检测。</p>
</li>
<li>
<p><strong>接收方反馈</strong>
在通电话场景下的 ACK （肯定确认） 和 NAK （否定确认）可以实现接收方反馈的功能。</p>
</li>
<li>
<p><strong>重传</strong>
接收方收到有差错的分组时，发送方将重传该分组。</p>
</li>
</ul>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg loading=lazy alt="rdt 2.0 fsm">
</a>
<figcaption>rdt 2.0 fsm</figcaption>
</figure></p>
<p>当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，也即此时<code>rdt_send</code>事件不会发生。因此，除非发送端确认接收端已经正确地收到它当前发送的数据，发送端是不会发送新数据的。实现此类行为特征的协议被称为 <strong>停等协议（<code>stop-and-wait protocol</code>）</strong> 。</p>
<h4 id=处理acknak分组受损的场景>处理ACK/NAK分组受损的场景</h4>
<p>rdt 2.0 的实现没有考虑ACK或者NAK分组受损的可能性，在这种场景下，发送端无法知道接收端是否成功接收了上一块发送的数据。</p>
<p>我们的解决方案是在数据分组中增加一个新字段，让发送端对其数据分组编号，即将发送数据分组的 <strong>序列号（<code>sequence number</code>）</strong> 放在该字段。</p>
<p>rdt 2.0 作为停止等待协议的一个简单实现，序列号的长度是1位就够了。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg loading=lazy alt="rdt 2.1 sender fsm">
</a>
<figcaption>rdt 2.1 sender fsm</figcaption>
</figure></p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg loading=lazy alt="rdt 2.1 receiver fsm">
</a>
<figcaption>rdt 2.1 receiver fsm</figcaption>
</figure></p>
<p>rdt 2.1 在发送端和接收端均使用了 ACK/NAK，当接收端收到失序分组时，接收端发送 ACK 。当受损分组到达接收端时，接收端发送 NAK。</p>
<p>rdt 2.2 要做的改进是当受损分组到达接收端时，接收端不发送 NAK，取而代之的是发送一个对最近正确收到的数据的 ACK 。这时需要给 ACK 分组也添加序列号，当发送端收到这个 ACK 时，发送端可以根据 ACK 分组的序列号去判断这个 ACK 分组代表的是接收端正确接收了它刚发送的数据亦或是接收端正确接受了它上一次发送的数据。
当发送端收到两个对同一个分组确认的 ACK 时，即收到重复的 ACK ，发送端就可以知道接收端未能正确收到被确认两次的分组的下一个分组。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg loading=lazy alt="rdt 2.2 sender fsm">
</a>
<figcaption>rdt 2.2 sender fsm</figcaption>
</figure></p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg loading=lazy alt="rdt 2.2 receiver fsm">
</a>
<figcaption>rdt 2.2 receiver fsm</figcaption>
</figure></p>
<h3 id=3-经具有比特差错的丢包信道的可靠数据运输30>3. 经具有比特差错的丢包信道的可靠数据运输：3.0</h3>
<p>这个场景下底层信道不但会产生比特受损外，还会有丢包的现象。所以协议现在必须处理另外两个关注的问题：</p>
<ol>
<li>怎么检测丢包</li>
<li>发生丢包后如何处理</li>
</ol>
<p>发送端可以选择一个合理的时间值，如果在这个时间段内，它没有收到这个分组的 ACK ，则重传该分组。即使在这种情况下引入了 <strong>冗余数组分组（<code>duplicate data packet</code>）</strong> 的可能性，但是 rdt 2.2 已经使用序列号处理冗余分组的情况。</p>
<p>实现基于时间的重传机制，需要一个 <strong>倒计数定时器（<code>countdown timer</code>）</strong> ，在一个给定的时间量过期后，可中断发送端。因此发送端需要以下功能：</p>
<ol>
<li>每次发送一个分组（包括第一次分组和重传分组），便启动一个定时器</li>
<li>响应定时器中断（采取适当的动作）</li>
<li>终止定时器</li>
</ol>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg loading=lazy alt="rdt 3.0 fsm sender">
</a>
<figcaption>rdt 3.0 fsm sender</figcaption>
</figure></p>
<p>因为分组序号在0和1之间交替，所以 rdt 3.0有时候被称为 <strong>比特交替协议（<code>alternating-bit protocol</code>）</strong> 。</p>
<h3 id=4-流水线可靠数据传输协议>4. 流水线可靠数据传输协议</h3>
<p>rdt 3.0 采用的是停等协议，这样会导致信道的利用率很低，性能会非常差。</p>
<p><figure>
<a href=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg>
<img src=https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg loading=lazy alt="pipelined protocol vs Stop-and-wait protocol">
</a>
<figcaption>pipelined protocol vs Stop-and-wait protocol</figcaption>
</figure></p>
<p>可以使用 <strong>流水线（<code>pipelining</code>)</strong> 技术使得分组可以同时发送，以提高性能。实现流水线技术的要点有：</p>
<ol>
<li><strong>序列号的范围需要增加</strong>，因为每个传送途中（非重传）的分组需要独一无二的序列号，而且同时可能存在多个在传送的未确认报文。</li>
<li><strong>发送端和接收端可能需要缓存多个分组</strong>，发送端至少需要缓存那些已发送但是还未确认的分组，接收端可能需要缓存那些已经正确接收的分组。</li>
<li>所需序列号范围和缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种基本方法：
a. <strong>回退 N 步（<code>Go-Back-N, GBN</code>）</strong>
b. <strong>选择重传（<code>Selective Repeat, SR</code>）</strong></li>
</ol>
<hr>
<h2 id=参考资料>参考资料</h2>
<ul>
<li>Kurose, J. F., & Ross, K. W. (2018). <em>计算机网络-自顶而下方法</em> (7th ed.). 机械工业出版社.</li>
<li><a class=link href=https://en.wikipedia.org/wiki/User_Datagram_Protocol target=_blank rel=noopener>Wikipedia : User Datagram Protocol</a></li>
</ul>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>MIT</span>
</section>
<section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>
Last updated on Sep 01, 2020 22:13 +0800
</span>
</section></footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/p/http/2/>
<div class=article-details>
<h2 class=article-title>HTTP/2</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%BA%94%E7%94%A8%E5%B1%82/>
<div class=article-details>
<h2 class=article-title>应用层</h2>
</div>
</a>
</article>
<article>
<a href=/p/ip/>
<div class=article-details>
<h2 class=article-title>IP</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>
<div class=article-details>
<h2 class=article-title>计算机网络</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%9F%9F%E5%90%8D%E5%92%8Cdns/>
<div class=article-details>
<h2 class=article-title>域名和DNS</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//hugo-theme-stack.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2019 -
2022 Huanghuang's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#一概述>一、概述</a>
<ol>
<li><a href=#端口号>端口号</a></li>
<li><a href=#多路复用和多路分解>多路复用和多路分解</a>
<ol>
<li><a href=#多路复用的实现>多路复用的实现</a></li>
<li><a href=#多路分解的实现>多路分解的实现</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#二udp>二、UDP</a>
<ol>
<li><a href=#udp-的特点>UDP 的特点</a></li>
<li><a href=#udp-数据报结构>UDP 数据报结构</a>
<ol>
<li><a href=#udp-协议头>UDP 协议头</a></li>
<li><a href=#udp-校验和>UDP 校验和</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#三可靠数据传输>三、可靠数据传输</a>
<ol>
<li><a href=#1-经完全可靠信道的可靠数据传输10>1. 经完全可靠信道的可靠数据传输：1.0</a></li>
<li><a href=#2-经具有比特差错信道的可靠数据传输20>2. 经具有比特差错信道的可靠数据传输：2.0</a>
<ol>
<li><a href=#arq-协议的定义>ARQ 协议的定义</a></li>
<li><a href=#arq-协议的实现>ARQ 协议的实现</a></li>
<li><a href=#处理acknak分组受损的场景>处理ACK/NAK分组受损的场景</a></li>
</ol>
</li>
<li><a href=#3-经具有比特差错的丢包信道的可靠数据运输30>3. 经具有比特差错的丢包信道的可靠数据运输：3.0</a></li>
<li><a href=#4-流水线可靠数据传输协议>4. 流水线可靠数据传输协议</a></li>
</ol>
</li>
<li><a href=#参考资料>参考资料</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>