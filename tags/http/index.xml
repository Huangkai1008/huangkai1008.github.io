<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>http on Huanghuang's Blog</title><link>https://huangkai1008.github.io/tags/http/</link><description>Recent content in http on Huanghuang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 10 Jul 2020 15:51:57 +0800</lastBuildDate><atom:link href="https://huangkai1008.github.io/tags/http/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP/2</title><link>https://huangkai1008.github.io/p/http/2/</link><pubDate>Fri, 10 Jul 2020 15:51:57 +0800</pubDate><guid>https://huangkai1008.github.io/p/http/2/</guid><description>HTTP/2 一、概述 HTTP/2 的主要目标是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。 为达成这些目标，HTTP/2 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。
为了实现 HTTP 工作组设定的性能目标，HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。
二、HTTP/1.x的缺陷 HTTP/1.x 实现简单是以牺牲性能为代价的：
客户端需要使用多个连接才能实现并发和缩短延迟 不会压缩请求和响应首部，从而导致不必要的网络流量 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下 三、二进制分帧层 HTTP/2 所有性能增强的核心在于新的二进制分帧层（Binary framing layer），它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。
这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制: HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。 HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。
这样一来，客户端和服务器为了相互理解，都必须使用新的二进制编码机制: HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然。 现有的应用不必担心这些变化，因为客户端和服务器会替我们完成必要的分帧工作。
数据流、消息和帧 数据流（Stream）：已建立的连接内的双向字节流，可以承载一条或多条消息。
消息（Message)：与逻辑请求或响应消息对应的完整的一系列帧
帧（Frame）：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流
所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流：
每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。</description></item><item><title>HTTP</title><link>https://huangkai1008.github.io/p/http/</link><pubDate>Fri, 12 Jun 2020 12:22:57 +0800</pubDate><guid>https://huangkai1008.github.io/p/http/</guid><description>HTTP 一、概述 超文本传输协议（HyperText Transfer Protocol, HTTP） 是 Web 的核心，HTTP 由客户端程序和服务器程序实现
HTTP 使用 TCP 作为它的支撑运输协议，因为 HTTP 服务器并不保存关于客户的任何信息，所以 HTTP 是一个无状态协议（stateless protocol）。
请求和响应报文 客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。
请求消息（requests） GET / HTTP/1.1 Host: developer.mozilla.org Accept-Language: fr 起始行（start line）：包含一个HTTP方法（method）、请求目标（request target） 和 HTTP 版本 （HTTP version）
消息头（headers）： 整个 header（包括其值）表现为单行形式
一个空行用来分隔首部和内容主体 Body
消息主体（body）
响应消息(responses) HTTP/1.1 200 OK Date: Sat, 09 Oct 2010 14:28:02 GMT Server: Apache Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT ETag: &amp;#34;51142bc1-7449-479b075b2891b&amp;#34; Accept-Ranges: bytes Content-Length: 29769 Content-Type: text/html &amp;lt;!</description></item><item><title>WSGI ASGI UWSGI的区别</title><link>https://huangkai1008.github.io/p/wsgi-asgi-uwsgi%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Thu, 24 Jan 2019 13:56:20 +0800</pubDate><guid>https://huangkai1008.github.io/p/wsgi-asgi-uwsgi%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>What is wsgi **CGI(通用网关接口， Common Gateway Interface/CGI)** **CGI是定义客户端与web服务器交流方式的程序**。&amp;lt;u&amp;gt;例如正常情况下客户端发来一个请求，根据HTTP协议Web服务器将请求内容解析出来，进过计算后，再将加us安出来的内容封装好，例如服务器返回一个HTML页面，并且根据HTTP协议构建返回内容的响应格式。涉及到TCP连接、HTTP原始请求和相应格式的这些，都由一个软件来完成，这时，以上的工作需要一个程序来完成，而这个程序便是CGI&amp;lt;/u&amp;gt;** **WSGI(Web服务器网关接口(Python Web Server Gateway Interface，WSGI)** `WSGI`就是基于`Python`的以`CGI`为标准做一些扩展的协议 What is uwsgi uWSGI，是指实现了WSGI协议的一个web服务器。即用来接受客户端请求，转发响应的程序
What is asgi 异步网关协议接口，一个介于网络协议服务和`Python`应用之间的标准接口，能够处理多种通用的协议类型，包括`HTTP`，`HTTP2`和`WebSocket` ASGI尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容HTTP请求响应以及WebSocket数据帧的序列格式。允许这些协议能通过网络或本地socket进行传输，以及让不同的协议被分配到不同的进程中
Difference between wsgi &amp;amp; asgi 1. Wsgi is based on `Http`, not support `websocket` 2. Asgi is the extension of wsgi.</description></item></channel></rss>